//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthCheckApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    statusGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatusGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    adopterOnly(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/adopter-only";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdopterOnly(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdopterOnly(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdopterOnly(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MediaApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    cacheStats(): Observable<DownloadUrlCacheStats> {
        let url_ = this.baseUrl + "/api/Media/cache-stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCacheStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCacheStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadUrlCacheStats>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadUrlCacheStats>;
        }));
    }

    protected processCacheStats(response: HttpResponseBase): Observable<DownloadUrlCacheStats> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadUrlCacheStats.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    cache(s3Url: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Media/cache/{s3Url}";
        if (s3Url === undefined || s3Url === null)
            throw new Error("The parameter 's3Url' must be defined.");
        url_ = url_.replace("{s3Url}", encodeURIComponent("" + s3Url));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PetsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    shelterGET(shelterId: string): Observable<GetPetsResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetsResponse>;
        }));
    }

    protected processShelterGET(response: HttpResponseBase): Observable<GetPetsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    shelterPOST(shelterId: string, body?: CreatePetRequest | undefined): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processShelterPOST(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PetResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param nextToken (optional) 
     * @param status (optional) 
     * @param species (optional) 
     * @param name (optional) 
     * @param breed (optional) 
     * @return OK
     */
    paginated(shelterId: string, pageSize?: number | undefined, nextToken?: string | undefined, status?: PetStatus | undefined, species?: string | undefined, name?: string | undefined, breed?: string | undefined): Observable<GetPaginatedPetsResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}/paginated?";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (nextToken === null)
            throw new Error("The parameter 'nextToken' cannot be null.");
        else if (nextToken !== undefined)
            url_ += "nextToken=" + encodeURIComponent("" + nextToken) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (species === null)
            throw new Error("The parameter 'species' cannot be null.");
        else if (species !== undefined)
            url_ += "species=" + encodeURIComponent("" + species) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (breed === null)
            throw new Error("The parameter 'breed' cannot be null.");
        else if (breed !== undefined)
            url_ += "breed=" + encodeURIComponent("" + breed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPaginatedPetsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPaginatedPetsResponse>;
        }));
    }

    protected processPaginated(response: HttpResponseBase): Observable<GetPaginatedPetsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPaginatedPetsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petsGET(id: string): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processPetsGET(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petsDELETE(id: string): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processPetsDELETE(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    statusPUT(id: string, body?: PetStatus | undefined): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processStatusPUT(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fileName (optional) 
     * @param contentType (optional) 
     * @param fileSizeBytes (optional) 
     * @return OK
     */
    uploadUrl(petId: string, fileName?: string | undefined, contentType?: string | undefined, fileSizeBytes?: number | undefined): Observable<PresignedUrlResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/upload-url?";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (contentType === null)
            throw new Error("The parameter 'contentType' cannot be null.");
        else if (contentType !== undefined)
            url_ += "contentType=" + encodeURIComponent("" + contentType) + "&";
        if (fileSizeBytes === null)
            throw new Error("The parameter 'fileSizeBytes' cannot be null.");
        else if (fileSizeBytes !== undefined)
            url_ += "fileSizeBytes=" + encodeURIComponent("" + fileSizeBytes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PresignedUrlResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PresignedUrlResponse>;
        }));
    }

    protected processUploadUrl(response: HttpResponseBase): Observable<PresignedUrlResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PresignedUrlResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadUrls(body?: GetPetImageDownloadUrlsRequest | undefined): Observable<PetImageDownloadUrlsResponse> {
        let url_ = this.baseUrl + "/api/Pets/images/download-urls";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetImageDownloadUrlsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetImageDownloadUrlsResponse>;
        }));
    }

    protected processDownloadUrls(response: HttpResponseBase): Observable<PetImageDownloadUrlsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetImageDownloadUrlsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ShelterAdminsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    shelterAdminsPOST(body?: CreateShelterAdminRequest | undefined): Observable<ShelterAdminResponse> {
        let url_ = this.baseUrl + "/api/internal/ShelterAdmins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterAdminsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterAdminsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdminResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdminResponse>;
        }));
    }

    protected processShelterAdminsPOST(response: HttpResponseBase): Observable<ShelterAdminResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdminResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profile(): Observable<ShelterAdmin> {
        let url_ = this.baseUrl + "/api/ShelterAdmins/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdmin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdmin>;
        }));
    }

    protected processProfile(response: HttpResponseBase): Observable<ShelterAdmin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdmin.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    shelterAdminsGET(userId: string): Observable<ShelterAdmin> {
        let url_ = this.baseUrl + "/api/ShelterAdmins/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterAdminsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterAdminsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdmin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdmin>;
        }));
    }

    protected processShelterAdminsGET(response: HttpResponseBase): Observable<ShelterAdmin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdmin.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SheltersApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    query(body?: QueryShelterRequest | undefined): Observable<Shelter> {
        let url_ = this.baseUrl + "/api/Shelters/my-shelter/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Shelter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Shelter>;
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<Shelter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Shelter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petStatistics(): Observable<ShelterPetStatisticsResponse> {
        let url_ = this.baseUrl + "/api/Shelters/my-shelter/pet-statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterPetStatisticsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterPetStatisticsResponse>;
        }));
    }

    protected processPetStatistics(response: HttpResponseBase): Observable<ShelterPetStatisticsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterPetStatisticsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petStatistics2(shelterId: string): Observable<ShelterPetStatisticsResponse> {
        let url_ = this.baseUrl + "/api/Shelters/{shelterId}/pet-statistics";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetStatistics2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetStatistics2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterPetStatisticsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterPetStatisticsResponse>;
        }));
    }

    protected processPetStatistics2(response: HttpResponseBase): Observable<ShelterPetStatisticsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterPetStatisticsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CreatePetRequest implements ICreatePetRequest {
    name!: string | undefined;
    species!: string | undefined;
    breed!: string | undefined;
    dateOfBirth!: string;
    gender!: string | undefined;
    description!: string | undefined;

    constructor(data?: ICreatePetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.species = _data["species"];
            this.breed = _data["breed"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.gender = _data["gender"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreatePetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["species"] = this.species;
        data["breed"] = this.breed;
        data["dateOfBirth"] = this.dateOfBirth;
        data["gender"] = this.gender;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreatePetRequest {
    name: string | undefined;
    species: string | undefined;
    breed: string | undefined;
    dateOfBirth: string;
    gender: string | undefined;
    description: string | undefined;
}

export class CreateShelterAdminRequest implements ICreateShelterAdminRequest {
    userId!: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;

    constructor(data?: ICreateShelterAdminRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.shelterName = _data["shelterName"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterWebsiteUrl = _data["shelterWebsiteUrl"];
            this.shelterAbn = _data["shelterAbn"];
            this.shelterDescription = _data["shelterDescription"];
        }
    }

    static fromJS(data: any): CreateShelterAdminRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShelterAdminRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["shelterName"] = this.shelterName;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterWebsiteUrl"] = this.shelterWebsiteUrl;
        data["shelterAbn"] = this.shelterAbn;
        data["shelterDescription"] = this.shelterDescription;
        return data;
    }
}

export interface ICreateShelterAdminRequest {
    userId: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
}

export class DownloadUrlCacheStats implements IDownloadUrlCacheStats {
    totalCachedUrls?: number;
    cacheHitRate?: number;
    cacheHits?: number;
    cacheMisses?: number;
    totalRequests?: number;

    constructor(data?: IDownloadUrlCacheStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCachedUrls = _data["totalCachedUrls"];
            this.cacheHitRate = _data["cacheHitRate"];
            this.cacheHits = _data["cacheHits"];
            this.cacheMisses = _data["cacheMisses"];
            this.totalRequests = _data["totalRequests"];
        }
    }

    static fromJS(data: any): DownloadUrlCacheStats {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadUrlCacheStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCachedUrls"] = this.totalCachedUrls;
        data["cacheHitRate"] = this.cacheHitRate;
        data["cacheHits"] = this.cacheHits;
        data["cacheMisses"] = this.cacheMisses;
        data["totalRequests"] = this.totalRequests;
        return data;
    }
}

export interface IDownloadUrlCacheStats {
    totalCachedUrls?: number;
    cacheHitRate?: number;
    cacheHits?: number;
    cacheMisses?: number;
    totalRequests?: number;
}

export class GetPaginatedPetsResponse implements IGetPaginatedPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    nextToken?: string | undefined;
    totalCount?: number;
    errorMessage?: string | undefined;

    constructor(data?: IGetPaginatedPetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["pets"])) {
                this.pets = [] as any;
                for (let item of _data["pets"])
                    this.pets!.push(Pet.fromJS(item));
            }
            this.nextToken = _data["nextToken"];
            this.totalCount = _data["totalCount"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPaginatedPetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaginatedPetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.pets)) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["nextToken"] = this.nextToken;
        data["totalCount"] = this.totalCount;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPaginatedPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    nextToken?: string | undefined;
    totalCount?: number;
    errorMessage?: string | undefined;
}

export class GetPetImageDownloadUrlsRequest implements IGetPetImageDownloadUrlsRequest {
    petRequests?: PetImageDownloadUrlRequest[] | undefined;

    constructor(data?: IGetPetImageDownloadUrlsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["petRequests"])) {
                this.petRequests = [] as any;
                for (let item of _data["petRequests"])
                    this.petRequests!.push(PetImageDownloadUrlRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPetImageDownloadUrlsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetImageDownloadUrlsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.petRequests)) {
            data["petRequests"] = [];
            for (let item of this.petRequests)
                data["petRequests"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGetPetImageDownloadUrlsRequest {
    petRequests?: PetImageDownloadUrlRequest[] | undefined;
}

export class GetPetsResponse implements IGetPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IGetPetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["pets"])) {
                this.pets = [] as any;
                for (let item of _data["pets"])
                    this.pets!.push(Pet.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.pets)) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    errorMessage?: string | undefined;
}

export class Pet implements IPet {
    petId?: string;
    name?: string | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    dateOfBirth?: string;
    gender?: string | undefined;
    status?: PetStatus;
    description?: string | undefined;
    createdAt?: string;
    shelterId?: string;
    mainImageFileExtension?: string | undefined;

    constructor(data?: IPet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            this.name = _data["name"];
            this.species = _data["species"];
            this.breed = _data["breed"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.gender = _data["gender"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"];
            this.shelterId = _data["shelterId"];
            this.mainImageFileExtension = _data["mainImageFileExtension"];
        }
    }

    static fromJS(data: any): Pet {
        data = typeof data === 'object' ? data : {};
        let result = new Pet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        data["name"] = this.name;
        data["species"] = this.species;
        data["breed"] = this.breed;
        data["dateOfBirth"] = this.dateOfBirth;
        data["gender"] = this.gender;
        data["status"] = this.status;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt;
        data["shelterId"] = this.shelterId;
        data["mainImageFileExtension"] = this.mainImageFileExtension;
        return data;
    }
}

export interface IPet {
    petId?: string;
    name?: string | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    dateOfBirth?: string;
    gender?: string | undefined;
    status?: PetStatus;
    description?: string | undefined;
    createdAt?: string;
    shelterId?: string;
    mainImageFileExtension?: string | undefined;
}

export class PetImageDownloadUrlRequest implements IPetImageDownloadUrlRequest {
    petId?: string;
    mainImageFileExtension?: string | undefined;

    constructor(data?: IPetImageDownloadUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            this.mainImageFileExtension = _data["mainImageFileExtension"];
        }
    }

    static fromJS(data: any): PetImageDownloadUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PetImageDownloadUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        data["mainImageFileExtension"] = this.mainImageFileExtension;
        return data;
    }
}

export interface IPetImageDownloadUrlRequest {
    petId?: string;
    mainImageFileExtension?: string | undefined;
}

export class PetImageDownloadUrlsResponse implements IPetImageDownloadUrlsResponse {
    success?: boolean;
    petImageUrls?: { [key: string]: string; } | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPetImageDownloadUrlsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (_data["petImageUrls"]) {
                this.petImageUrls = {} as any;
                for (let key in _data["petImageUrls"]) {
                    if (_data["petImageUrls"].hasOwnProperty(key))
                        (<any>this.petImageUrls)![key] = _data["petImageUrls"][key];
                }
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PetImageDownloadUrlsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetImageDownloadUrlsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.petImageUrls) {
            data["petImageUrls"] = {};
            for (let key in this.petImageUrls) {
                if (this.petImageUrls.hasOwnProperty(key))
                    (<any>data["petImageUrls"])[key] = (<any>this.petImageUrls)[key];
            }
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPetImageDownloadUrlsResponse {
    success?: boolean;
    petImageUrls?: { [key: string]: string; } | undefined;
    errorMessage?: string | undefined;
}

export class PetResponse implements IPetResponse {
    success?: boolean;
    pet?: Pet;
    errorMessage?: string | undefined;

    constructor(data?: IPetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.pet = _data["pet"] ? Pet.fromJS(_data["pet"]) : <any>undefined;
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["pet"] = this.pet ? this.pet.toJSON() : <any>undefined;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPetResponse {
    success?: boolean;
    pet?: Pet;
    errorMessage?: string | undefined;
}

export enum PetStatus {
    Available = "Available",
    Pending = "Pending",
    Adopted = "Adopted",
    MedicalHold = "MedicalHold",
}

export class PresignedUrlResponse implements IPresignedUrlResponse {
    success?: boolean;
    presignedUrl?: string | undefined;
    key?: string | undefined;
    expiresAt?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPresignedUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.presignedUrl = _data["presignedUrl"];
            this.key = _data["key"];
            this.expiresAt = _data["expiresAt"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PresignedUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PresignedUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["presignedUrl"] = this.presignedUrl;
        data["key"] = this.key;
        data["expiresAt"] = this.expiresAt;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPresignedUrlResponse {
    success?: boolean;
    presignedUrl?: string | undefined;
    key?: string | undefined;
    expiresAt?: string | undefined;
    errorMessage?: string | undefined;
}

export class QueryShelterRequest implements IQueryShelterRequest {
    attributesToGet?: string[] | undefined;

    constructor(data?: IQueryShelterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributesToGet"])) {
                this.attributesToGet = [] as any;
                for (let item of _data["attributesToGet"])
                    this.attributesToGet!.push(item);
            }
        }
    }

    static fromJS(data: any): QueryShelterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QueryShelterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributesToGet)) {
            data["attributesToGet"] = [];
            for (let item of this.attributesToGet)
                data["attributesToGet"].push(item);
        }
        return data;
    }
}

export interface IQueryShelterRequest {
    attributesToGet?: string[] | undefined;
}

export class Shelter implements IShelter {
    shelterId!: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    isActive?: boolean;
    createdAt?: string;
    updatedAt?: string;

    constructor(data?: IShelter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shelterId = _data["shelterId"];
            this.shelterName = _data["shelterName"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterWebsiteUrl = _data["shelterWebsiteUrl"];
            this.shelterAbn = _data["shelterAbn"];
            this.shelterDescription = _data["shelterDescription"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"];
            this.updatedAt = _data["updatedAt"];
        }
    }

    static fromJS(data: any): Shelter {
        data = typeof data === 'object' ? data : {};
        let result = new Shelter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shelterId"] = this.shelterId;
        data["shelterName"] = this.shelterName;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterWebsiteUrl"] = this.shelterWebsiteUrl;
        data["shelterAbn"] = this.shelterAbn;
        data["shelterDescription"] = this.shelterDescription;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        return data;
    }
}

export interface IShelter {
    shelterId: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    isActive?: boolean;
    createdAt?: string;
    updatedAt?: string;
}

export class ShelterAdmin implements IShelterAdmin {
    userId!: string;
    shelterId!: string;
    createdAt?: string;
    updatedAt?: string;

    constructor(data?: IShelterAdmin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.shelterId = _data["shelterId"];
            this.createdAt = _data["createdAt"];
            this.updatedAt = _data["updatedAt"];
        }
    }

    static fromJS(data: any): ShelterAdmin {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdmin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["shelterId"] = this.shelterId;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        return data;
    }
}

export interface IShelterAdmin {
    userId: string;
    shelterId: string;
    createdAt?: string;
    updatedAt?: string;
}

export class ShelterAdminResponse implements IShelterAdminResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string;
    shelterId?: string;

    constructor(data?: IShelterAdminResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.userId = _data["userId"];
            this.shelterId = _data["shelterId"];
        }
    }

    static fromJS(data: any): ShelterAdminResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdminResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["userId"] = this.userId;
        data["shelterId"] = this.shelterId;
        return data;
    }
}

export interface IShelterAdminResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string;
    shelterId?: string;
}

export class ShelterPetStatisticsResponse implements IShelterPetStatisticsResponse {
    success?: boolean;
    totalPets?: number;
    adoptedPets?: number;
    errorMessage?: string | undefined;
    fromCache?: boolean;
    lastUpdated?: string;

    constructor(data?: IShelterPetStatisticsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.totalPets = _data["totalPets"];
            this.adoptedPets = _data["adoptedPets"];
            this.errorMessage = _data["errorMessage"];
            this.fromCache = _data["fromCache"];
            this.lastUpdated = _data["lastUpdated"];
        }
    }

    static fromJS(data: any): ShelterPetStatisticsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterPetStatisticsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["totalPets"] = this.totalPets;
        data["adoptedPets"] = this.adoptedPets;
        data["errorMessage"] = this.errorMessage;
        data["fromCache"] = this.fromCache;
        data["lastUpdated"] = this.lastUpdated;
        return data;
    }
}

export interface IShelterPetStatisticsResponse {
    success?: boolean;
    totalPets?: number;
    adoptedPets?: number;
    errorMessage?: string | undefined;
    fromCache?: boolean;
    lastUpdated?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}