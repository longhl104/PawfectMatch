//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthCheckApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    statusGET(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStatusGET(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    adopterOnly(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/adopter-only";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdopterOnly(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdopterOnly(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdopterOnly(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/AuthCheck/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MediaApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    cacheStats(): Observable<DownloadUrlCacheStats> {
        let url_ = this.baseUrl + "/api/Media/cache-stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCacheStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCacheStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DownloadUrlCacheStats>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DownloadUrlCacheStats>;
        }));
    }

    protected processCacheStats(response: HttpResponseBase): Observable<DownloadUrlCacheStats> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DownloadUrlCacheStats.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    cache(s3Url: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Media/cache/{s3Url}";
        if (s3Url === undefined || s3Url === null)
            throw new Error("The parameter 's3Url' must be defined.");
        url_ = url_.replace("{s3Url}", encodeURIComponent("" + s3Url));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PetsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    species(): Observable<GetPetSpeciesResponse> {
        let url_ = this.baseUrl + "/api/Pets/species";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetSpeciesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetSpeciesResponse>;
        }));
    }

    protected processSpecies(response: HttpResponseBase): Observable<GetPetSpeciesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetSpeciesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    species2(): Observable<GetPetSpeciesResponse> {
        let url_ = this.baseUrl + "/api/internal/Pets/species";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpecies2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpecies2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetSpeciesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetSpeciesResponse>;
        }));
    }

    protected processSpecies2(response: HttpResponseBase): Observable<GetPetSpeciesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetSpeciesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    breeds(speciesId: number): Observable<GetPetBreedsResponse> {
        let url_ = this.baseUrl + "/api/Pets/species/{speciesId}/breeds";
        if (speciesId === undefined || speciesId === null)
            throw new Error("The parameter 'speciesId' must be defined.");
        url_ = url_.replace("{speciesId}", encodeURIComponent("" + speciesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBreeds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBreeds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetBreedsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetBreedsResponse>;
        }));
    }

    protected processBreeds(response: HttpResponseBase): Observable<GetPetBreedsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetBreedsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    breeds2(speciesId: number): Observable<GetPetBreedsResponse> {
        let url_ = this.baseUrl + "/api/internal/Pets/species/{speciesId}/breeds";
        if (speciesId === undefined || speciesId === null)
            throw new Error("The parameter 'speciesId' must be defined.");
        url_ = url_.replace("{speciesId}", encodeURIComponent("" + speciesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBreeds2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBreeds2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetBreedsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetBreedsResponse>;
        }));
    }

    protected processBreeds2(response: HttpResponseBase): Observable<GetPetBreedsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetBreedsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param latitude (optional) 
     * @param longitude (optional) 
     * @param maxDistanceKm (optional) 
     * @param speciesId (optional) 
     * @param breedId (optional) 
     * @param pageSize (optional) 
     * @param nextToken (optional) 
     * @return OK
     */
    search(latitude?: number | undefined, longitude?: number | undefined, maxDistanceKm?: number | undefined, speciesId?: number | undefined, breedId?: number | undefined, pageSize?: number | undefined, nextToken?: string | undefined): Observable<PetSearchResponse> {
        let url_ = this.baseUrl + "/api/internal/Pets/search?";
        if (latitude === null)
            throw new Error("The parameter 'latitude' cannot be null.");
        else if (latitude !== undefined)
            url_ += "latitude=" + encodeURIComponent("" + latitude) + "&";
        if (longitude === null)
            throw new Error("The parameter 'longitude' cannot be null.");
        else if (longitude !== undefined)
            url_ += "longitude=" + encodeURIComponent("" + longitude) + "&";
        if (maxDistanceKm === null)
            throw new Error("The parameter 'maxDistanceKm' cannot be null.");
        else if (maxDistanceKm !== undefined)
            url_ += "maxDistanceKm=" + encodeURIComponent("" + maxDistanceKm) + "&";
        if (speciesId === null)
            throw new Error("The parameter 'speciesId' cannot be null.");
        else if (speciesId !== undefined)
            url_ += "speciesId=" + encodeURIComponent("" + speciesId) + "&";
        if (breedId === null)
            throw new Error("The parameter 'breedId' cannot be null.");
        else if (breedId !== undefined)
            url_ += "breedId=" + encodeURIComponent("" + breedId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (nextToken === null)
            throw new Error("The parameter 'nextToken' cannot be null.");
        else if (nextToken !== undefined)
            url_ += "nextToken=" + encodeURIComponent("" + nextToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetSearchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetSearchResponse>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<PetSearchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetSearchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    shelterGET(shelterId: string): Observable<GetPetsResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetsResponse>;
        }));
    }

    protected processShelterGET(response: HttpResponseBase): Observable<GetPetsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    shelterPOST(shelterId: string, body?: CreatePetRequest | undefined): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processShelterPOST(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PetResponse.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param nextToken (optional) 
     * @param status (optional) 
     * @param species (optional) 
     * @param name (optional) 
     * @param breed (optional) 
     * @return OK
     */
    paginated(shelterId: string, pageSize?: number | undefined, nextToken?: string | undefined, status?: PetStatus | undefined, species?: string | undefined, name?: string | undefined, breed?: string | undefined): Observable<GetPaginatedPetsResponse> {
        let url_ = this.baseUrl + "/api/Pets/shelter/{shelterId}/paginated?";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (nextToken === null)
            throw new Error("The parameter 'nextToken' cannot be null.");
        else if (nextToken !== undefined)
            url_ += "nextToken=" + encodeURIComponent("" + nextToken) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (species === null)
            throw new Error("The parameter 'species' cannot be null.");
        else if (species !== undefined)
            url_ += "species=" + encodeURIComponent("" + species) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (breed === null)
            throw new Error("The parameter 'breed' cannot be null.");
        else if (breed !== undefined)
            url_ += "breed=" + encodeURIComponent("" + breed) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPaginatedPetsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPaginatedPetsResponse>;
        }));
    }

    protected processPaginated(response: HttpResponseBase): Observable<GetPaginatedPetsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPaginatedPetsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petsGET(id: string): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processPetsGET(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    petsPUT(id: string, body?: UpdatePetRequest | undefined): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetsPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetsPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processPetsPUT(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petsDELETE(id: string): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetsDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetsDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processPetsDELETE(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    statusPUT(id: string, body?: PetStatus | undefined): Observable<PetResponse> {
        let url_ = this.baseUrl + "/api/Pets/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatusPUT(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatusPUT(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetResponse>;
        }));
    }

    protected processStatusPUT(response: HttpResponseBase): Observable<PetResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fileName (optional) 
     * @param contentType (optional) 
     * @param fileSizeBytes (optional) 
     * @return OK
     */
    uploadUrl(petId: string, fileName?: string | undefined, contentType?: string | undefined, fileSizeBytes?: number | undefined): Observable<PresignedUrlResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/upload-url?";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        if (contentType === null)
            throw new Error("The parameter 'contentType' cannot be null.");
        else if (contentType !== undefined)
            url_ += "contentType=" + encodeURIComponent("" + contentType) + "&";
        if (fileSizeBytes === null)
            throw new Error("The parameter 'fileSizeBytes' cannot be null.");
        else if (fileSizeBytes !== undefined)
            url_ += "fileSizeBytes=" + encodeURIComponent("" + fileSizeBytes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PresignedUrlResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PresignedUrlResponse>;
        }));
    }

    protected processUploadUrl(response: HttpResponseBase): Observable<PresignedUrlResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PresignedUrlResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    downloadUrls(body?: GetPetImageDownloadUrlsRequest | undefined): Observable<PetImageDownloadUrlsResponse> {
        let url_ = this.baseUrl + "/api/Pets/images/download-urls";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PetImageDownloadUrlsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PetImageDownloadUrlsResponse>;
        }));
    }

    protected processDownloadUrls(response: HttpResponseBase): Observable<PetImageDownloadUrlsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PetImageDownloadUrlsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    mediaGET(petId: string): Observable<GetPetMediaResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/media";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMediaGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMediaGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetMediaResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetMediaResponse>;
        }));
    }

    protected processMediaGET(response: HttpResponseBase): Observable<GetPetMediaResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetMediaResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    mediaDELETE(petId: string, body?: DeleteMediaFilesRequest | undefined): Observable<DeleteMediaFilesResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/media";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMediaDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMediaDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeleteMediaFilesResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeleteMediaFilesResponse>;
        }));
    }

    protected processMediaDELETE(response: HttpResponseBase): Observable<DeleteMediaFilesResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteMediaFilesResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadUrls(petId: string, body?: UploadMediaFilesRequest | undefined): Observable<MediaFileUploadResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/media/upload-urls";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaFileUploadResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaFileUploadResponse>;
        }));
    }

    protected processUploadUrls(response: HttpResponseBase): Observable<MediaFileUploadResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MediaFileUploadResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    confirmUploads(petId: string, body?: string[] | undefined): Observable<GetPetMediaResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/media/confirm-uploads";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUploads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUploads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetMediaResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetMediaResponse>;
        }));
    }

    protected processConfirmUploads(response: HttpResponseBase): Observable<GetPetMediaResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetMediaResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reorder(petId: string, body?: { [key: string]: number; } | undefined): Observable<GetPetMediaResponse> {
        let url_ = this.baseUrl + "/api/Pets/{petId}/media/reorder";
        if (petId === undefined || petId === null)
            throw new Error("The parameter 'petId' must be defined.");
        url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPetMediaResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPetMediaResponse>;
        }));
    }

    protected processReorder(response: HttpResponseBase): Observable<GetPetMediaResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPetMediaResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ShelterAdminsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    shelterAdminsPOST(body?: CreateShelterAdminRequest | undefined): Observable<ShelterAdminResponse> {
        let url_ = this.baseUrl + "/api/internal/ShelterAdmins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterAdminsPOST(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterAdminsPOST(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdminResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdminResponse>;
        }));
    }

    protected processShelterAdminsPOST(response: HttpResponseBase): Observable<ShelterAdminResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdminResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    profile(): Observable<ShelterAdmin> {
        let url_ = this.baseUrl + "/api/ShelterAdmins/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdmin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdmin>;
        }));
    }

    protected processProfile(response: HttpResponseBase): Observable<ShelterAdmin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdmin.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    shelterAdminsGET(userId: string): Observable<ShelterAdmin> {
        let url_ = this.baseUrl + "/api/ShelterAdmins/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterAdminsGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterAdminsGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdmin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdmin>;
        }));
    }

    protected processShelterAdminsGET(response: HttpResponseBase): Observable<ShelterAdmin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdmin.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SheltersApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    query(body?: QueryShelterRequest | undefined): Observable<Shelter> {
        let url_ = this.baseUrl + "/api/Shelters/my-shelter/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Shelter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Shelter>;
        }));
    }

    protected processQuery(response: HttpResponseBase): Observable<Shelter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Shelter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petStatistics(): Observable<ShelterPetStatisticsResponse> {
        let url_ = this.baseUrl + "/api/Shelters/my-shelter/pet-statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterPetStatisticsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterPetStatisticsResponse>;
        }));
    }

    protected processPetStatistics(response: HttpResponseBase): Observable<ShelterPetStatisticsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterPetStatisticsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return OK
     */
    petStatistics2(shelterId: string): Observable<ShelterPetStatisticsResponse> {
        let url_ = this.baseUrl + "/api/Shelters/{shelterId}/pet-statistics";
        if (shelterId === undefined || shelterId === null)
            throw new Error("The parameter 'shelterId' must be defined.");
        url_ = url_.replace("{shelterId}", encodeURIComponent("" + shelterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPetStatistics2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPetStatistics2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterPetStatisticsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterPetStatisticsResponse>;
        }));
    }

    protected processPetStatistics2(response: HttpResponseBase): Observable<ShelterPetStatisticsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterPetStatisticsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class CreatePetRequest implements ICreatePetRequest {
    name!: string | undefined;
    speciesId!: number;
    breedId!: number;
    dateOfBirth!: string;
    gender!: string | undefined;
    description!: string | undefined;
    adoptionFee?: number;
    weight?: number | undefined;
    color?: string | undefined;
    isSpayedNeutered?: boolean;
    isVaccinated?: boolean;
    isMicrochipped?: boolean;
    isHouseTrained?: boolean;
    isGoodWithKids?: boolean;
    isGoodWithPets?: boolean;
    specialNeeds?: string | undefined;
    status?: PetStatus;

    constructor(data?: ICreatePetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.speciesId = _data["speciesId"];
            this.breedId = _data["breedId"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.gender = _data["gender"];
            this.description = _data["description"];
            this.adoptionFee = _data["adoptionFee"];
            this.weight = _data["weight"];
            this.color = _data["color"];
            this.isSpayedNeutered = _data["isSpayedNeutered"];
            this.isVaccinated = _data["isVaccinated"];
            this.isMicrochipped = _data["isMicrochipped"];
            this.isHouseTrained = _data["isHouseTrained"];
            this.isGoodWithKids = _data["isGoodWithKids"];
            this.isGoodWithPets = _data["isGoodWithPets"];
            this.specialNeeds = _data["specialNeeds"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreatePetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["speciesId"] = this.speciesId;
        data["breedId"] = this.breedId;
        data["dateOfBirth"] = this.dateOfBirth;
        data["gender"] = this.gender;
        data["description"] = this.description;
        data["adoptionFee"] = this.adoptionFee;
        data["weight"] = this.weight;
        data["color"] = this.color;
        data["isSpayedNeutered"] = this.isSpayedNeutered;
        data["isVaccinated"] = this.isVaccinated;
        data["isMicrochipped"] = this.isMicrochipped;
        data["isHouseTrained"] = this.isHouseTrained;
        data["isGoodWithKids"] = this.isGoodWithKids;
        data["isGoodWithPets"] = this.isGoodWithPets;
        data["specialNeeds"] = this.specialNeeds;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreatePetRequest {
    name: string | undefined;
    speciesId: number;
    breedId: number;
    dateOfBirth: string;
    gender: string | undefined;
    description: string | undefined;
    adoptionFee?: number;
    weight?: number | undefined;
    color?: string | undefined;
    isSpayedNeutered?: boolean;
    isVaccinated?: boolean;
    isMicrochipped?: boolean;
    isHouseTrained?: boolean;
    isGoodWithKids?: boolean;
    isGoodWithPets?: boolean;
    specialNeeds?: string | undefined;
    status?: PetStatus;
}

export class CreateShelterAdminRequest implements ICreateShelterAdminRequest {
    userId!: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;

    constructor(data?: ICreateShelterAdminRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.shelterName = _data["shelterName"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterWebsiteUrl = _data["shelterWebsiteUrl"];
            this.shelterAbn = _data["shelterAbn"];
            this.shelterDescription = _data["shelterDescription"];
            this.shelterLatitude = _data["shelterLatitude"];
            this.shelterLongitude = _data["shelterLongitude"];
        }
    }

    static fromJS(data: any): CreateShelterAdminRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShelterAdminRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["shelterName"] = this.shelterName;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterWebsiteUrl"] = this.shelterWebsiteUrl;
        data["shelterAbn"] = this.shelterAbn;
        data["shelterDescription"] = this.shelterDescription;
        data["shelterLatitude"] = this.shelterLatitude;
        data["shelterLongitude"] = this.shelterLongitude;
        return data;
    }
}

export interface ICreateShelterAdminRequest {
    userId: string;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;
}

export class DeleteMediaFilesRequest implements IDeleteMediaFilesRequest {
    mediaFileIds?: string[] | undefined;

    constructor(data?: IDeleteMediaFilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mediaFileIds"])) {
                this.mediaFileIds = [] as any;
                for (let item of _data["mediaFileIds"])
                    this.mediaFileIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteMediaFilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMediaFilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mediaFileIds)) {
            data["mediaFileIds"] = [];
            for (let item of this.mediaFileIds)
                data["mediaFileIds"].push(item);
        }
        return data;
    }
}

export interface IDeleteMediaFilesRequest {
    mediaFileIds?: string[] | undefined;
}

export class DeleteMediaFilesResponse implements IDeleteMediaFilesResponse {
    success?: boolean;
    deletedCount?: number;
    failedDeletes?: string[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IDeleteMediaFilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.deletedCount = _data["deletedCount"];
            if (Array.isArray(_data["failedDeletes"])) {
                this.failedDeletes = [] as any;
                for (let item of _data["failedDeletes"])
                    this.failedDeletes!.push(item);
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): DeleteMediaFilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMediaFilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["deletedCount"] = this.deletedCount;
        if (Array.isArray(this.failedDeletes)) {
            data["failedDeletes"] = [];
            for (let item of this.failedDeletes)
                data["failedDeletes"].push(item);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IDeleteMediaFilesResponse {
    success?: boolean;
    deletedCount?: number;
    failedDeletes?: string[] | undefined;
    errorMessage?: string | undefined;
}

export class DownloadUrlCacheStats implements IDownloadUrlCacheStats {
    totalCachedUrls?: number;
    cacheHitRate?: number;
    cacheHits?: number;
    cacheMisses?: number;
    totalRequests?: number;

    constructor(data?: IDownloadUrlCacheStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCachedUrls = _data["totalCachedUrls"];
            this.cacheHitRate = _data["cacheHitRate"];
            this.cacheHits = _data["cacheHits"];
            this.cacheMisses = _data["cacheMisses"];
            this.totalRequests = _data["totalRequests"];
        }
    }

    static fromJS(data: any): DownloadUrlCacheStats {
        data = typeof data === 'object' ? data : {};
        let result = new DownloadUrlCacheStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCachedUrls"] = this.totalCachedUrls;
        data["cacheHitRate"] = this.cacheHitRate;
        data["cacheHits"] = this.cacheHits;
        data["cacheMisses"] = this.cacheMisses;
        data["totalRequests"] = this.totalRequests;
        return data;
    }
}

export interface IDownloadUrlCacheStats {
    totalCachedUrls?: number;
    cacheHitRate?: number;
    cacheHits?: number;
    cacheMisses?: number;
    totalRequests?: number;
}

export class GetPaginatedPetsResponse implements IGetPaginatedPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    nextToken?: string | undefined;
    totalCount?: number;
    errorMessage?: string | undefined;

    constructor(data?: IGetPaginatedPetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["pets"])) {
                this.pets = [] as any;
                for (let item of _data["pets"])
                    this.pets!.push(Pet.fromJS(item));
            }
            this.nextToken = _data["nextToken"];
            this.totalCount = _data["totalCount"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPaginatedPetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPaginatedPetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.pets)) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["nextToken"] = this.nextToken;
        data["totalCount"] = this.totalCount;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPaginatedPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    nextToken?: string | undefined;
    totalCount?: number;
    errorMessage?: string | undefined;
}

export class GetPetBreedsResponse implements IGetPetBreedsResponse {
    success?: boolean;
    breeds?: PetBreedDto[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IGetPetBreedsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["breeds"])) {
                this.breeds = [] as any;
                for (let item of _data["breeds"])
                    this.breeds!.push(PetBreedDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPetBreedsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetBreedsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.breeds)) {
            data["breeds"] = [];
            for (let item of this.breeds)
                data["breeds"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPetBreedsResponse {
    success?: boolean;
    breeds?: PetBreedDto[] | undefined;
    errorMessage?: string | undefined;
}

export class GetPetImageDownloadUrlsRequest implements IGetPetImageDownloadUrlsRequest {
    petRequests?: PetImageDownloadUrlRequest[] | undefined;

    constructor(data?: IGetPetImageDownloadUrlsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["petRequests"])) {
                this.petRequests = [] as any;
                for (let item of _data["petRequests"])
                    this.petRequests!.push(PetImageDownloadUrlRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPetImageDownloadUrlsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetImageDownloadUrlsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.petRequests)) {
            data["petRequests"] = [];
            for (let item of this.petRequests)
                data["petRequests"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IGetPetImageDownloadUrlsRequest {
    petRequests?: PetImageDownloadUrlRequest[] | undefined;
}

export class GetPetMediaResponse implements IGetPetMediaResponse {
    success?: boolean;
    images?: PetMediaFileResponse[] | undefined;
    videos?: PetMediaFileResponse[] | undefined;
    documents?: PetMediaFileResponse[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IGetPetMediaResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(PetMediaFileResponse.fromJS(item));
            }
            if (Array.isArray(_data["videos"])) {
                this.videos = [] as any;
                for (let item of _data["videos"])
                    this.videos!.push(PetMediaFileResponse.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(PetMediaFileResponse.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPetMediaResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetMediaResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.videos)) {
            data["videos"] = [];
            for (let item of this.videos)
                data["videos"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPetMediaResponse {
    success?: boolean;
    images?: PetMediaFileResponse[] | undefined;
    videos?: PetMediaFileResponse[] | undefined;
    documents?: PetMediaFileResponse[] | undefined;
    errorMessage?: string | undefined;
}

export class GetPetSpeciesResponse implements IGetPetSpeciesResponse {
    success?: boolean;
    species?: PetSpeciesDto[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IGetPetSpeciesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["species"])) {
                this.species = [] as any;
                for (let item of _data["species"])
                    this.species!.push(PetSpeciesDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPetSpeciesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetSpeciesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.species)) {
            data["species"] = [];
            for (let item of this.species)
                data["species"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPetSpeciesResponse {
    success?: boolean;
    species?: PetSpeciesDto[] | undefined;
    errorMessage?: string | undefined;
}

export class GetPetsResponse implements IGetPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IGetPetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["pets"])) {
                this.pets = [] as any;
                for (let item of _data["pets"])
                    this.pets!.push(Pet.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): GetPetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.pets)) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IGetPetsResponse {
    success?: boolean;
    pets?: Pet[] | undefined;
    errorMessage?: string | undefined;
}

export enum MediaFileType {
    Image = "Image",
    Video = "Video",
    Document = "Document",
}

export class MediaFileUploadRequest implements IMediaFileUploadRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;
    fileSizeBytes?: number;
    fileType?: MediaFileType;

    constructor(data?: IMediaFileUploadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.fileSizeBytes = _data["fileSizeBytes"];
            this.fileType = _data["fileType"];
        }
    }

    static fromJS(data: any): MediaFileUploadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MediaFileUploadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["fileSizeBytes"] = this.fileSizeBytes;
        data["fileType"] = this.fileType;
        return data;
    }
}

export interface IMediaFileUploadRequest {
    fileName?: string | undefined;
    contentType?: string | undefined;
    fileSizeBytes?: number;
    fileType?: MediaFileType;
}

export class MediaFileUploadResponse implements IMediaFileUploadResponse {
    success?: boolean;
    uploadUrls?: MediaFileUploadUrlResponse[] | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IMediaFileUploadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["uploadUrls"])) {
                this.uploadUrls = [] as any;
                for (let item of _data["uploadUrls"])
                    this.uploadUrls!.push(MediaFileUploadUrlResponse.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): MediaFileUploadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MediaFileUploadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.uploadUrls)) {
            data["uploadUrls"] = [];
            for (let item of this.uploadUrls)
                data["uploadUrls"].push(item ? item.toJSON() : <any>undefined);
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IMediaFileUploadResponse {
    success?: boolean;
    uploadUrls?: MediaFileUploadUrlResponse[] | undefined;
    errorMessage?: string | undefined;
}

export class MediaFileUploadUrlResponse implements IMediaFileUploadUrlResponse {
    mediaFileId?: string;
    fileName?: string | undefined;
    presignedUrl?: string | undefined;
    s3Key?: string | undefined;
    expiresAt?: string;

    constructor(data?: IMediaFileUploadUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediaFileId = _data["mediaFileId"];
            this.fileName = _data["fileName"];
            this.presignedUrl = _data["presignedUrl"];
            this.s3Key = _data["s3Key"];
            this.expiresAt = _data["expiresAt"];
        }
    }

    static fromJS(data: any): MediaFileUploadUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MediaFileUploadUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediaFileId"] = this.mediaFileId;
        data["fileName"] = this.fileName;
        data["presignedUrl"] = this.presignedUrl;
        data["s3Key"] = this.s3Key;
        data["expiresAt"] = this.expiresAt;
        return data;
    }
}

export interface IMediaFileUploadUrlResponse {
    mediaFileId?: string;
    fileName?: string | undefined;
    presignedUrl?: string | undefined;
    s3Key?: string | undefined;
    expiresAt?: string;
}

export class Pet implements IPet {
    petId!: string;
    weight?: number | undefined;
    color?: string | undefined;
    specialNeeds?: string | undefined;
    petPostgreSqlId!: number;
    mainImageFileExtension?: string | undefined;
    description?: string | undefined;
    status?: PetStatus;
    createdAt?: string | undefined;
    adoptionFee?: number | undefined;
    gender?: string | undefined;
    dateOfBirth?: string | undefined;
    name?: string | undefined;
    isSpayedNeutered?: boolean | undefined;
    isHouseTrained?: boolean | undefined;
    isGoodWithKids?: boolean | undefined;
    isGoodWithPets?: boolean | undefined;
    isVaccinated?: boolean | undefined;
    isMicrochipped?: boolean | undefined;
    speciesId?: number | undefined;
    breedId?: number | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    shelterId?: string | undefined;

    constructor(data?: IPet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            this.weight = _data["weight"];
            this.color = _data["color"];
            this.specialNeeds = _data["specialNeeds"];
            this.petPostgreSqlId = _data["petPostgreSqlId"];
            this.mainImageFileExtension = _data["mainImageFileExtension"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"];
            this.adoptionFee = _data["adoptionFee"];
            this.gender = _data["gender"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.name = _data["name"];
            this.isSpayedNeutered = _data["isSpayedNeutered"];
            this.isHouseTrained = _data["isHouseTrained"];
            this.isGoodWithKids = _data["isGoodWithKids"];
            this.isGoodWithPets = _data["isGoodWithPets"];
            this.isVaccinated = _data["isVaccinated"];
            this.isMicrochipped = _data["isMicrochipped"];
            this.speciesId = _data["speciesId"];
            this.breedId = _data["breedId"];
            this.species = _data["species"];
            this.breed = _data["breed"];
            this.shelterId = _data["shelterId"];
        }
    }

    static fromJS(data: any): Pet {
        data = typeof data === 'object' ? data : {};
        let result = new Pet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        data["weight"] = this.weight;
        data["color"] = this.color;
        data["specialNeeds"] = this.specialNeeds;
        data["petPostgreSqlId"] = this.petPostgreSqlId;
        data["mainImageFileExtension"] = this.mainImageFileExtension;
        data["description"] = this.description;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt;
        data["adoptionFee"] = this.adoptionFee;
        data["gender"] = this.gender;
        data["dateOfBirth"] = this.dateOfBirth;
        data["name"] = this.name;
        data["isSpayedNeutered"] = this.isSpayedNeutered;
        data["isHouseTrained"] = this.isHouseTrained;
        data["isGoodWithKids"] = this.isGoodWithKids;
        data["isGoodWithPets"] = this.isGoodWithPets;
        data["isVaccinated"] = this.isVaccinated;
        data["isMicrochipped"] = this.isMicrochipped;
        data["speciesId"] = this.speciesId;
        data["breedId"] = this.breedId;
        data["species"] = this.species;
        data["breed"] = this.breed;
        data["shelterId"] = this.shelterId;
        return data;
    }
}

export interface IPet {
    petId: string;
    weight?: number | undefined;
    color?: string | undefined;
    specialNeeds?: string | undefined;
    petPostgreSqlId: number;
    mainImageFileExtension?: string | undefined;
    description?: string | undefined;
    status?: PetStatus;
    createdAt?: string | undefined;
    adoptionFee?: number | undefined;
    gender?: string | undefined;
    dateOfBirth?: string | undefined;
    name?: string | undefined;
    isSpayedNeutered?: boolean | undefined;
    isHouseTrained?: boolean | undefined;
    isGoodWithKids?: boolean | undefined;
    isGoodWithPets?: boolean | undefined;
    isVaccinated?: boolean | undefined;
    isMicrochipped?: boolean | undefined;
    speciesId?: number | undefined;
    breedId?: number | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    shelterId?: string | undefined;
}

export class PetBreedDto implements IPetBreedDto {
    breedId?: number;
    name?: string | undefined;
    speciesId?: number;

    constructor(data?: IPetBreedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.breedId = _data["breedId"];
            this.name = _data["name"];
            this.speciesId = _data["speciesId"];
        }
    }

    static fromJS(data: any): PetBreedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PetBreedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["breedId"] = this.breedId;
        data["name"] = this.name;
        data["speciesId"] = this.speciesId;
        return data;
    }
}

export interface IPetBreedDto {
    breedId?: number;
    name?: string | undefined;
    speciesId?: number;
}

export class PetImageDownloadUrlRequest implements IPetImageDownloadUrlRequest {
    petId?: string;
    mainImageFileExtension?: string | undefined;

    constructor(data?: IPetImageDownloadUrlRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            this.mainImageFileExtension = _data["mainImageFileExtension"];
        }
    }

    static fromJS(data: any): PetImageDownloadUrlRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PetImageDownloadUrlRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        data["mainImageFileExtension"] = this.mainImageFileExtension;
        return data;
    }
}

export interface IPetImageDownloadUrlRequest {
    petId?: string;
    mainImageFileExtension?: string | undefined;
}

export class PetImageDownloadUrlsResponse implements IPetImageDownloadUrlsResponse {
    success?: boolean;
    petImageUrls?: { [key: string]: string; } | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPetImageDownloadUrlsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (_data["petImageUrls"]) {
                this.petImageUrls = {} as any;
                for (let key in _data["petImageUrls"]) {
                    if (_data["petImageUrls"].hasOwnProperty(key))
                        (<any>this.petImageUrls)![key] = _data["petImageUrls"][key];
                }
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PetImageDownloadUrlsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetImageDownloadUrlsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (this.petImageUrls) {
            data["petImageUrls"] = {};
            for (let key in this.petImageUrls) {
                if (this.petImageUrls.hasOwnProperty(key))
                    (<any>data["petImageUrls"])[key] = (<any>this.petImageUrls)[key];
            }
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPetImageDownloadUrlsResponse {
    success?: boolean;
    petImageUrls?: { [key: string]: string; } | undefined;
    errorMessage?: string | undefined;
}

export class PetMediaFileResponse implements IPetMediaFileResponse {
    mediaFileId?: string;
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    fileType?: MediaFileType;
    contentType?: string | undefined;
    fileSizeBytes?: number | undefined;
    downloadUrl?: string | undefined;
    uploadedAt?: string;
    displayOrder?: number;

    constructor(data?: IPetMediaFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mediaFileId = _data["mediaFileId"];
            this.fileName = _data["fileName"];
            this.fileExtension = _data["fileExtension"];
            this.fileType = _data["fileType"];
            this.contentType = _data["contentType"];
            this.fileSizeBytes = _data["fileSizeBytes"];
            this.downloadUrl = _data["downloadUrl"];
            this.uploadedAt = _data["uploadedAt"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): PetMediaFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetMediaFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mediaFileId"] = this.mediaFileId;
        data["fileName"] = this.fileName;
        data["fileExtension"] = this.fileExtension;
        data["fileType"] = this.fileType;
        data["contentType"] = this.contentType;
        data["fileSizeBytes"] = this.fileSizeBytes;
        data["downloadUrl"] = this.downloadUrl;
        data["uploadedAt"] = this.uploadedAt;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IPetMediaFileResponse {
    mediaFileId?: string;
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    fileType?: MediaFileType;
    contentType?: string | undefined;
    fileSizeBytes?: number | undefined;
    downloadUrl?: string | undefined;
    uploadedAt?: string;
    displayOrder?: number;
}

export class PetResponse implements IPetResponse {
    success?: boolean;
    pet?: Pet;
    errorMessage?: string | undefined;

    constructor(data?: IPetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.pet = _data["pet"] ? Pet.fromJS(_data["pet"]) : <any>undefined;
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["pet"] = this.pet ? this.pet.toJSON() : <any>undefined;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPetResponse {
    success?: boolean;
    pet?: Pet;
    errorMessage?: string | undefined;
}

export class PetSearchResponse implements IPetSearchResponse {
    success?: boolean;
    pets?: PetSearchResultDto[] | undefined;
    totalCount?: number;
    nextToken?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPetSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["pets"])) {
                this.pets = [] as any;
                for (let item of _data["pets"])
                    this.pets!.push(PetSearchResultDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.nextToken = _data["nextToken"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PetSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PetSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.pets)) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item ? item.toJSON() : <any>undefined);
        }
        data["totalCount"] = this.totalCount;
        data["nextToken"] = this.nextToken;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPetSearchResponse {
    success?: boolean;
    pets?: PetSearchResultDto[] | undefined;
    totalCount?: number;
    nextToken?: string | undefined;
    errorMessage?: string | undefined;
}

export class PetSearchResultDto implements IPetSearchResultDto {
    petId?: string;
    name?: string | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    ageInMonths?: number | undefined;
    gender?: string | undefined;
    description?: string | undefined;
    adoptionFee?: number | undefined;
    mainImageFileExtension?: string | undefined;
    shelter?: PetSearchShelterDto;
    distanceKm?: number;

    constructor(data?: IPetSearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            this.name = _data["name"];
            this.species = _data["species"];
            this.breed = _data["breed"];
            this.ageInMonths = _data["ageInMonths"];
            this.gender = _data["gender"];
            this.description = _data["description"];
            this.adoptionFee = _data["adoptionFee"];
            this.mainImageFileExtension = _data["mainImageFileExtension"];
            this.shelter = _data["shelter"] ? PetSearchShelterDto.fromJS(_data["shelter"]) : <any>undefined;
            this.distanceKm = _data["distanceKm"];
        }
    }

    static fromJS(data: any): PetSearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PetSearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        data["name"] = this.name;
        data["species"] = this.species;
        data["breed"] = this.breed;
        data["ageInMonths"] = this.ageInMonths;
        data["gender"] = this.gender;
        data["description"] = this.description;
        data["adoptionFee"] = this.adoptionFee;
        data["mainImageFileExtension"] = this.mainImageFileExtension;
        data["shelter"] = this.shelter ? this.shelter.toJSON() : <any>undefined;
        data["distanceKm"] = this.distanceKm;
        return data;
    }
}

export interface IPetSearchResultDto {
    petId?: string;
    name?: string | undefined;
    species?: string | undefined;
    breed?: string | undefined;
    ageInMonths?: number | undefined;
    gender?: string | undefined;
    description?: string | undefined;
    adoptionFee?: number | undefined;
    mainImageFileExtension?: string | undefined;
    shelter?: PetSearchShelterDto;
    distanceKm?: number;
}

export class PetSearchShelterDto implements IPetSearchShelterDto {
    shelterId?: string;
    shelterName?: string | undefined;
    shelterAddress?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;

    constructor(data?: IPetSearchShelterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shelterId = _data["shelterId"];
            this.shelterName = _data["shelterName"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterLatitude = _data["shelterLatitude"];
            this.shelterLongitude = _data["shelterLongitude"];
        }
    }

    static fromJS(data: any): PetSearchShelterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PetSearchShelterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shelterId"] = this.shelterId;
        data["shelterName"] = this.shelterName;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterLatitude"] = this.shelterLatitude;
        data["shelterLongitude"] = this.shelterLongitude;
        return data;
    }
}

export interface IPetSearchShelterDto {
    shelterId?: string;
    shelterName?: string | undefined;
    shelterAddress?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;
}

export class PetSpeciesDto implements IPetSpeciesDto {
    speciesId?: number;
    name?: string | undefined;

    constructor(data?: IPetSpeciesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.speciesId = _data["speciesId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PetSpeciesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PetSpeciesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["speciesId"] = this.speciesId;
        data["name"] = this.name;
        return data;
    }
}

export interface IPetSpeciesDto {
    speciesId?: number;
    name?: string | undefined;
}

export enum PetStatus {
    Available = "Available",
    Pending = "Pending",
    Adopted = "Adopted",
    MedicalHold = "MedicalHold",
}

export class PresignedUrlResponse implements IPresignedUrlResponse {
    success?: boolean;
    presignedUrl?: string | undefined;
    key?: string | undefined;
    expiresAt?: string | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IPresignedUrlResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.presignedUrl = _data["presignedUrl"];
            this.key = _data["key"];
            this.expiresAt = _data["expiresAt"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): PresignedUrlResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PresignedUrlResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["presignedUrl"] = this.presignedUrl;
        data["key"] = this.key;
        data["expiresAt"] = this.expiresAt;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IPresignedUrlResponse {
    success?: boolean;
    presignedUrl?: string | undefined;
    key?: string | undefined;
    expiresAt?: string | undefined;
    errorMessage?: string | undefined;
}

export class QueryShelterRequest implements IQueryShelterRequest {
    attributesToGet?: string[] | undefined;

    constructor(data?: IQueryShelterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributesToGet"])) {
                this.attributesToGet = [] as any;
                for (let item of _data["attributesToGet"])
                    this.attributesToGet!.push(item);
            }
        }
    }

    static fromJS(data: any): QueryShelterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QueryShelterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributesToGet)) {
            data["attributesToGet"] = [];
            for (let item of this.attributesToGet)
                data["attributesToGet"].push(item);
        }
        return data;
    }
}

export interface IQueryShelterRequest {
    attributesToGet?: string[] | undefined;
}

export class Shelter implements IShelter {
    shelterId!: string;
    shelterPostgreSqlId!: number;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    createdAt?: string;
    updatedAt?: string;

    constructor(data?: IShelter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shelterId = _data["shelterId"];
            this.shelterPostgreSqlId = _data["shelterPostgreSqlId"];
            this.shelterName = _data["shelterName"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterLatitude = _data["shelterLatitude"];
            this.shelterLongitude = _data["shelterLongitude"];
            this.shelterWebsiteUrl = _data["shelterWebsiteUrl"];
            this.shelterAbn = _data["shelterAbn"];
            this.shelterDescription = _data["shelterDescription"];
            this.createdAt = _data["createdAt"];
            this.updatedAt = _data["updatedAt"];
        }
    }

    static fromJS(data: any): Shelter {
        data = typeof data === 'object' ? data : {};
        let result = new Shelter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shelterId"] = this.shelterId;
        data["shelterPostgreSqlId"] = this.shelterPostgreSqlId;
        data["shelterName"] = this.shelterName;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterLatitude"] = this.shelterLatitude;
        data["shelterLongitude"] = this.shelterLongitude;
        data["shelterWebsiteUrl"] = this.shelterWebsiteUrl;
        data["shelterAbn"] = this.shelterAbn;
        data["shelterDescription"] = this.shelterDescription;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        return data;
    }
}

export interface IShelter {
    shelterId: string;
    shelterPostgreSqlId: number;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    createdAt?: string;
    updatedAt?: string;
}

export class ShelterAdmin implements IShelterAdmin {
    userId!: string;
    shelterId!: string;
    createdAt?: string;
    updatedAt?: string;

    constructor(data?: IShelterAdmin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.shelterId = _data["shelterId"];
            this.createdAt = _data["createdAt"];
            this.updatedAt = _data["updatedAt"];
        }
    }

    static fromJS(data: any): ShelterAdmin {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdmin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["shelterId"] = this.shelterId;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        return data;
    }
}

export interface IShelterAdmin {
    userId: string;
    shelterId: string;
    createdAt?: string;
    updatedAt?: string;
}

export class ShelterAdminResponse implements IShelterAdminResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string;
    shelterId?: string;

    constructor(data?: IShelterAdminResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.userId = _data["userId"];
            this.shelterId = _data["shelterId"];
        }
    }

    static fromJS(data: any): ShelterAdminResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdminResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["userId"] = this.userId;
        data["shelterId"] = this.shelterId;
        return data;
    }
}

export interface IShelterAdminResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string;
    shelterId?: string;
}

export class ShelterPetStatisticsResponse implements IShelterPetStatisticsResponse {
    success?: boolean;
    totalPets?: number;
    adoptedPets?: number;
    errorMessage?: string | undefined;
    fromCache?: boolean;
    lastUpdated?: string;

    constructor(data?: IShelterPetStatisticsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.totalPets = _data["totalPets"];
            this.adoptedPets = _data["adoptedPets"];
            this.errorMessage = _data["errorMessage"];
            this.fromCache = _data["fromCache"];
            this.lastUpdated = _data["lastUpdated"];
        }
    }

    static fromJS(data: any): ShelterPetStatisticsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterPetStatisticsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["totalPets"] = this.totalPets;
        data["adoptedPets"] = this.adoptedPets;
        data["errorMessage"] = this.errorMessage;
        data["fromCache"] = this.fromCache;
        data["lastUpdated"] = this.lastUpdated;
        return data;
    }
}

export interface IShelterPetStatisticsResponse {
    success?: boolean;
    totalPets?: number;
    adoptedPets?: number;
    errorMessage?: string | undefined;
    fromCache?: boolean;
    lastUpdated?: string;
}

export class UpdatePetRequest implements IUpdatePetRequest {
    name!: string | undefined;
    speciesId!: number;
    breedId!: number;
    dateOfBirth!: string;
    gender!: string | undefined;
    description!: string | undefined;
    adoptionFee?: number;
    weight?: number | undefined;
    color?: string | undefined;
    isSpayedNeutered?: boolean;
    isVaccinated?: boolean;
    isMicrochipped?: boolean;
    isHouseTrained?: boolean;
    isGoodWithKids?: boolean;
    isGoodWithPets?: boolean;
    specialNeeds?: string | undefined;
    status?: PetStatus;

    constructor(data?: IUpdatePetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.speciesId = _data["speciesId"];
            this.breedId = _data["breedId"];
            this.dateOfBirth = _data["dateOfBirth"];
            this.gender = _data["gender"];
            this.description = _data["description"];
            this.adoptionFee = _data["adoptionFee"];
            this.weight = _data["weight"];
            this.color = _data["color"];
            this.isSpayedNeutered = _data["isSpayedNeutered"];
            this.isVaccinated = _data["isVaccinated"];
            this.isMicrochipped = _data["isMicrochipped"];
            this.isHouseTrained = _data["isHouseTrained"];
            this.isGoodWithKids = _data["isGoodWithKids"];
            this.isGoodWithPets = _data["isGoodWithPets"];
            this.specialNeeds = _data["specialNeeds"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdatePetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["speciesId"] = this.speciesId;
        data["breedId"] = this.breedId;
        data["dateOfBirth"] = this.dateOfBirth;
        data["gender"] = this.gender;
        data["description"] = this.description;
        data["adoptionFee"] = this.adoptionFee;
        data["weight"] = this.weight;
        data["color"] = this.color;
        data["isSpayedNeutered"] = this.isSpayedNeutered;
        data["isVaccinated"] = this.isVaccinated;
        data["isMicrochipped"] = this.isMicrochipped;
        data["isHouseTrained"] = this.isHouseTrained;
        data["isGoodWithKids"] = this.isGoodWithKids;
        data["isGoodWithPets"] = this.isGoodWithPets;
        data["specialNeeds"] = this.specialNeeds;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdatePetRequest {
    name: string | undefined;
    speciesId: number;
    breedId: number;
    dateOfBirth: string;
    gender: string | undefined;
    description: string | undefined;
    adoptionFee?: number;
    weight?: number | undefined;
    color?: string | undefined;
    isSpayedNeutered?: boolean;
    isVaccinated?: boolean;
    isMicrochipped?: boolean;
    isHouseTrained?: boolean;
    isGoodWithKids?: boolean;
    isGoodWithPets?: boolean;
    specialNeeds?: string | undefined;
    status?: PetStatus;
}

export class UploadMediaFilesRequest implements IUploadMediaFilesRequest {
    petId?: string;
    mediaFiles?: MediaFileUploadRequest[] | undefined;

    constructor(data?: IUploadMediaFilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.petId = _data["petId"];
            if (Array.isArray(_data["mediaFiles"])) {
                this.mediaFiles = [] as any;
                for (let item of _data["mediaFiles"])
                    this.mediaFiles!.push(MediaFileUploadRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadMediaFilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UploadMediaFilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["petId"] = this.petId;
        if (Array.isArray(this.mediaFiles)) {
            data["mediaFiles"] = [];
            for (let item of this.mediaFiles)
                data["mediaFiles"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IUploadMediaFilesRequest {
    petId?: string;
    mediaFiles?: MediaFileUploadRequest[] | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}