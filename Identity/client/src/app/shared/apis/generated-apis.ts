//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Authenticate user and return tokens
     * @param body (optional) 
     * @return OK
     */
    login(body?: LoginRequest | undefined): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Logout user and invalidate tokens
     * @return OK
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Initiate password reset process
     * @param body (optional) 
     * @return OK
     */
    forgotPassword(body?: ForgotPasswordRequest | undefined): Observable<ForgotPasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ForgotPasswordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ForgotPasswordResponse>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ForgotPasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ForgotPasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Confirm password reset with verification code
     * @param body (optional) 
     * @return OK
     */
    resetPassword(body?: ResetPasswordRequest | undefined): Observable<ResetPasswordResponse> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordResponse>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegistrationApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Register a new adopter
     * @param body (optional) 
     * @return OK
     */
    adopter(body?: AdopterRegistrationRequest | undefined): Observable<AdopterRegistrationResponse> {
        let url_ = this.baseUrl + "/api/Registration/adopter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdopter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdopter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdopterRegistrationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdopterRegistrationResponse>;
        }));
    }

    protected processAdopter(response: HttpResponseBase): Observable<AdopterRegistrationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdopterRegistrationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Register a new shelter admin
     * @param body (optional) 
     * @return OK
     */
    shelterAdmin(body?: ShelterAdminRegistrationRequest | undefined): Observable<ShelterAdminRegistrationResponse> {
        let url_ = this.baseUrl + "/api/Registration/shelter-admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShelterAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShelterAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShelterAdminRegistrationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShelterAdminRegistrationResponse>;
        }));
    }

    protected processShelterAdmin(response: HttpResponseBase): Observable<ShelterAdminRegistrationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelterAdminRegistrationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AdopterRegistrationRequest implements IAdopterRegistrationRequest {
    fullName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    bio?: string | undefined;

    constructor(data?: IAdopterRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.bio = _data["bio"];
        }
    }

    static fromJS(data: any): AdopterRegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AdopterRegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["bio"] = this.bio;
        return data;
    }
}

export interface IAdopterRegistrationRequest {
    fullName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    phoneNumber?: string | undefined;
    address?: string | undefined;
    bio?: string | undefined;
}

export class AdopterRegistrationResponse implements IAdopterRegistrationResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string | undefined;
    redirectUrl?: string | undefined;
    data?: TokenData;

    constructor(data?: IAdopterRegistrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.userId = _data["userId"];
            this.redirectUrl = _data["redirectUrl"];
            this.data = _data["data"] ? TokenData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdopterRegistrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdopterRegistrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["userId"] = this.userId;
        data["redirectUrl"] = this.redirectUrl;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAdopterRegistrationResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string | undefined;
    redirectUrl?: string | undefined;
    data?: TokenData;
}

/** Request model for password reset initiation */
export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

/** Request model for password reset initiation */
export interface IForgotPasswordRequest {
    email?: string | undefined;
}

/** Response model for password reset initiation */
export class ForgotPasswordResponse implements IForgotPasswordResponse {
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IForgotPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ForgotPasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

/** Response model for password reset initiation */
export interface IForgotPasswordResponse {
    success?: boolean;
    message?: string | undefined;
}

/** Request model for user authentication */
export class LoginRequest implements ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

/** Request model for user authentication */
export interface ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;
}

/** Response model for login operations */
export class LoginResponse implements ILoginResponse {
    success?: boolean;
    message?: string | undefined;
    data?: TokenData;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.data = _data["data"] ? TokenData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Response model for login operations */
export interface ILoginResponse {
    success?: boolean;
    message?: string | undefined;
    data?: TokenData;
}

/** Request model for confirming password reset */
export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string | undefined;
    resetCode?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

/** Request model for confirming password reset */
export interface IResetPasswordRequest {
    email?: string | undefined;
    resetCode?: string | undefined;
    newPassword?: string | undefined;
}

/** Response model for password reset confirmation */
export class ResetPasswordResponse implements IResetPasswordResponse {
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IResetPasswordResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ResetPasswordResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

/** Response model for password reset confirmation */
export interface IResetPasswordResponse {
    success?: boolean;
    message?: string | undefined;
}

export class ShelterAdminRegistrationRequest implements IShelterAdminRegistrationRequest {
    email?: string | undefined;
    password?: string | undefined;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;

    constructor(data?: IShelterAdminRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.shelterName = _data["shelterName"];
            this.shelterContactNumber = _data["shelterContactNumber"];
            this.shelterAddress = _data["shelterAddress"];
            this.shelterWebsiteUrl = _data["shelterWebsiteUrl"];
            this.shelterAbn = _data["shelterAbn"];
            this.shelterDescription = _data["shelterDescription"];
            this.shelterLatitude = _data["shelterLatitude"];
            this.shelterLongitude = _data["shelterLongitude"];
        }
    }

    static fromJS(data: any): ShelterAdminRegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdminRegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["shelterName"] = this.shelterName;
        data["shelterContactNumber"] = this.shelterContactNumber;
        data["shelterAddress"] = this.shelterAddress;
        data["shelterWebsiteUrl"] = this.shelterWebsiteUrl;
        data["shelterAbn"] = this.shelterAbn;
        data["shelterDescription"] = this.shelterDescription;
        data["shelterLatitude"] = this.shelterLatitude;
        data["shelterLongitude"] = this.shelterLongitude;
        return data;
    }
}

export interface IShelterAdminRegistrationRequest {
    email?: string | undefined;
    password?: string | undefined;
    shelterName?: string | undefined;
    shelterContactNumber?: string | undefined;
    shelterAddress?: string | undefined;
    shelterWebsiteUrl?: string | undefined;
    shelterAbn?: string | undefined;
    shelterDescription?: string | undefined;
    shelterLatitude?: number | undefined;
    shelterLongitude?: number | undefined;
}

export class ShelterAdminRegistrationResponse implements IShelterAdminRegistrationResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string | undefined;
    redirectUrl?: string | undefined;
    data?: TokenData;

    constructor(data?: IShelterAdminRegistrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
            this.userId = _data["userId"];
            this.redirectUrl = _data["redirectUrl"];
            this.data = _data["data"] ? TokenData.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShelterAdminRegistrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShelterAdminRegistrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        data["userId"] = this.userId;
        data["redirectUrl"] = this.redirectUrl;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IShelterAdminRegistrationResponse {
    success?: boolean;
    message?: string | undefined;
    userId?: string | undefined;
    redirectUrl?: string | undefined;
    data?: TokenData;
}

/** Contains token data for authentication */
export class TokenData implements ITokenData {
    accessToken?: string | undefined;
    idToken?: string | undefined;
    refreshToken?: string | undefined;
    expiresAt?: string;
    user?: UserProfile;

    constructor(data?: ITokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.idToken = _data["idToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"];
            this.user = _data["user"] ? UserProfile.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenData {
        data = typeof data === 'object' ? data : {};
        let result = new TokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["idToken"] = this.idToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains token data for authentication */
export interface ITokenData {
    accessToken?: string | undefined;
    idToken?: string | undefined;
    refreshToken?: string | undefined;
    expiresAt?: string;
    user?: UserProfile;
}

export class UserProfile implements IUserProfile {
    userId!: string;
    email?: string | undefined;
    userType?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    createdAt?: string;
    lastLoginAt?: string;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.userType = _data["userType"];
            this.phoneNumber = _data["phoneNumber"];
            this.fullName = _data["fullName"];
            this.createdAt = _data["createdAt"];
            this.lastLoginAt = _data["lastLoginAt"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["userType"] = this.userType;
        data["phoneNumber"] = this.phoneNumber;
        data["fullName"] = this.fullName;
        data["createdAt"] = this.createdAt;
        data["lastLoginAt"] = this.lastLoginAt;
        return data;
    }
}

export interface IUserProfile {
    userId: string;
    email?: string | undefined;
    userType?: string | undefined;
    phoneNumber?: string | undefined;
    fullName?: string | undefined;
    createdAt?: string;
    lastLoginAt?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}